{"version":3,"sources":["../node_modules/@ionic/core/dist/esm-es5/ion-virtual-scroll.entry.js"],"names":["createNode","el","type","template","getTemplate","ownerDocument","importNode","content","children","querySelector","calcCells","items","itemHeight","headerHeight","footerHeight","headerFn","footerFn","approxHeaderHeight","approxFooterHeight","approxItemHeight","j","offset","len","cells","end","i","value","item","push","index","height","reads","visible","VirtualScroll","class_1","hostRef","_this","this","range","length","viewportHeight","virtualDom","isEnabled","viewportOffset","currentScrollTop","indexDirty","lastItemLen","totalHeight","onScroll","updateVirtualScroll","prototype","itemsChanged","connectedCallback","contentEl","_a","_b","label","closest","getScrollElement","console","error","scrollEl","sent","updateState","componentDidUpdate","disconnectedCallback","undefined","onResize","positionForItem","Promise","resolve","positionForIndex","heightIndex","cell","find","c","getHeightIndex","checkRange","cellIndex","findCellIndex","max","findIndex","inplaceUpdate","dst","src","Math","scheduleUpdate","checkEnd","timerUpdate","clearTimeout","readVS","bind","writeVS","topOffset","node","offsetTop","offsetParent","offsetHeight","scrollTop","dirtyIndex","viewport","getViewport","vierportHeight","margin","top","bottom","getRange","buffer","topPos","bottomPos","min","getShouldUpdate","currentRange","updateVDom","dom","_i","dom_1","change","d","toMutate","_loop_1","n","pool","filter","_loop_2","toMutate_1","forEach","nodeRender","doRender","updateCellHeight","child","Array","from","tagName","childrenNu","newChild","classList","add","appendChild","style","transform","remove","domRender","renderItem","update","window","getComputedStyle","parseFloat","getPropertyValue","setCellHeight","componentOnReady","then","setTimeout","shouldEnable","enableScrollEvents","Infinity","calcHeightIndex","resizeBuffer","buf","Uint32Array","newBuf","set","subarray","acum","shouldListen","rmEvent","addEventListener","removeEventListener","renderVirtualNode","renderHeader","renderFooter","render","VirtualProxy","map","Object","defineProperty","get","enumerable","configurable","utils","vattrs","classes","class","assign"],"mappings":"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","file":"static/js/50.265cbffd.chunk.js","sourcesContent":["import { __awaiter, __generator } from \"tslib\";\nimport { r as registerInstance, f as readTask, c as writeTask, j as forceUpdate, h, H as Host, i as getElement } from './index-92848855.js';\nvar CELL_TYPE_ITEM = 'item';\nvar CELL_TYPE_HEADER = 'header';\nvar CELL_TYPE_FOOTER = 'footer';\nvar NODE_CHANGE_NONE = 0;\nvar NODE_CHANGE_POSITION = 1;\nvar NODE_CHANGE_CELL = 2;\nvar MIN_READS = 2;\n\nvar updateVDom = function updateVDom(dom, heightIndex, cells, range) {\n  // reset dom\n  for (var _i = 0, dom_1 = dom; _i < dom_1.length; _i++) {\n    var node = dom_1[_i];\n    node.change = NODE_CHANGE_NONE;\n    node.d = true;\n  } // try to match into exisiting dom\n\n\n  var toMutate = [];\n  var end = range.offset + range.length;\n\n  var _loop_1 = function _loop_1(i) {\n    var cell = cells[i];\n    var node = dom.find(function (n) {\n      return n.d && n.cell === cell;\n    });\n\n    if (node) {\n      var top = heightIndex[i];\n\n      if (top !== node.top) {\n        node.top = top;\n        node.change = NODE_CHANGE_POSITION;\n      }\n\n      node.d = false;\n    } else {\n      toMutate.push(cell);\n    }\n  };\n\n  for (var i = range.offset; i < end; i++) {\n    _loop_1(i);\n  } // needs to append\n\n\n  var pool = dom.filter(function (n) {\n    return n.d;\n  });\n\n  var _loop_2 = function _loop_2(cell) {\n    var node = pool.find(function (n) {\n      return n.d && n.cell.type === cell.type;\n    });\n    var index = cell.i;\n\n    if (node) {\n      node.d = false;\n      node.change = NODE_CHANGE_CELL;\n      node.cell = cell;\n      node.top = heightIndex[index];\n    } else {\n      dom.push({\n        d: false,\n        cell: cell,\n        visible: true,\n        change: NODE_CHANGE_CELL,\n        top: heightIndex[index]\n      });\n    }\n  };\n\n  for (var _a = 0, toMutate_1 = toMutate; _a < toMutate_1.length; _a++) {\n    var cell = toMutate_1[_a];\n\n    _loop_2(cell);\n  }\n\n  dom.filter(function (n) {\n    return n.d && n.top !== -9999;\n  }).forEach(function (n) {\n    n.change = NODE_CHANGE_POSITION;\n    n.top = -9999;\n  });\n};\n\nvar doRender = function doRender(el, nodeRender, dom, updateCellHeight) {\n  var children = Array.from(el.children).filter(function (n) {\n    return n.tagName !== 'TEMPLATE';\n  });\n  var childrenNu = children.length;\n  var child;\n\n  for (var i = 0; i < dom.length; i++) {\n    var node = dom[i];\n    var cell = node.cell; // the cell change, the content must be updated\n\n    if (node.change === NODE_CHANGE_CELL) {\n      if (i < childrenNu) {\n        child = children[i];\n        nodeRender(child, cell, i);\n      } else {\n        var newChild = createNode(el, cell.type);\n        child = nodeRender(newChild, cell, i) || newChild;\n        child.classList.add('virtual-item');\n        el.appendChild(child);\n      }\n\n      child['$ionCell'] = cell;\n    } else {\n      child = children[i];\n    } // only update position when it changes\n\n\n    if (node.change !== NODE_CHANGE_NONE) {\n      child.style.transform = \"translate3d(0,\" + node.top + \"px,0)\";\n    } // update visibility\n\n\n    var visible = cell.visible;\n\n    if (node.visible !== visible) {\n      if (visible) {\n        child.classList.remove('virtual-loading');\n      } else {\n        child.classList.add('virtual-loading');\n      }\n\n      node.visible = visible;\n    } // dynamic height\n\n\n    if (cell.reads > 0) {\n      updateCellHeight(cell, child);\n      cell.reads--;\n    }\n  }\n};\n\nvar createNode = function createNode(el, type) {\n  var template = getTemplate(el, type);\n\n  if (template && el.ownerDocument) {\n    return el.ownerDocument.importNode(template.content, true).children[0];\n  }\n\n  return null;\n};\n\nvar getTemplate = function getTemplate(el, type) {\n  switch (type) {\n    case CELL_TYPE_ITEM:\n      return el.querySelector('template:not([name])');\n\n    case CELL_TYPE_HEADER:\n      return el.querySelector('template[name=header]');\n\n    case CELL_TYPE_FOOTER:\n      return el.querySelector('template[name=footer]');\n  }\n};\n\nvar getViewport = function getViewport(scrollTop, vierportHeight, margin) {\n  return {\n    top: Math.max(scrollTop - margin, 0),\n    bottom: scrollTop + vierportHeight + margin\n  };\n};\n\nvar getRange = function getRange(heightIndex, viewport, buffer) {\n  var topPos = viewport.top;\n  var bottomPos = viewport.bottom; // find top index\n\n  var i = 0;\n\n  for (; i < heightIndex.length; i++) {\n    if (heightIndex[i] > topPos) {\n      break;\n    }\n  }\n\n  var offset = Math.max(i - buffer - 1, 0); // find bottom index\n\n  for (; i < heightIndex.length; i++) {\n    if (heightIndex[i] >= bottomPos) {\n      break;\n    }\n  }\n\n  var end = Math.min(i + buffer, heightIndex.length);\n  var length = end - offset;\n  return {\n    offset: offset,\n    length: length\n  };\n};\n\nvar getShouldUpdate = function getShouldUpdate(dirtyIndex, currentRange, range) {\n  var end = range.offset + range.length;\n  return dirtyIndex <= end || currentRange.offset !== range.offset || currentRange.length !== range.length;\n};\n\nvar findCellIndex = function findCellIndex(cells, index) {\n  var max = cells.length > 0 ? cells[cells.length - 1].index : 0;\n\n  if (index === 0) {\n    return 0;\n  } else if (index === max + 1) {\n    return cells.length;\n  } else {\n    return cells.findIndex(function (c) {\n      return c.index === index;\n    });\n  }\n};\n\nvar inplaceUpdate = function inplaceUpdate(dst, src, offset) {\n  if (offset === 0 && src.length >= dst.length) {\n    return src;\n  }\n\n  for (var i = 0; i < src.length; i++) {\n    dst[i + offset] = src[i];\n  }\n\n  return dst;\n};\n\nvar calcCells = function calcCells(items, itemHeight, headerHeight, footerHeight, headerFn, footerFn, approxHeaderHeight, approxFooterHeight, approxItemHeight, j, offset, len) {\n  var cells = [];\n  var end = len + offset;\n\n  for (var i = offset; i < end; i++) {\n    var item = items[i];\n\n    if (headerFn) {\n      var value = headerFn(item, i, items);\n\n      if (value != null) {\n        cells.push({\n          i: j++,\n          type: CELL_TYPE_HEADER,\n          value: value,\n          index: i,\n          height: headerHeight ? headerHeight(value, i) : approxHeaderHeight,\n          reads: headerHeight ? 0 : MIN_READS,\n          visible: !!headerHeight\n        });\n      }\n    }\n\n    cells.push({\n      i: j++,\n      type: CELL_TYPE_ITEM,\n      value: item,\n      index: i,\n      height: itemHeight ? itemHeight(item, i) : approxItemHeight,\n      reads: itemHeight ? 0 : MIN_READS,\n      visible: !!itemHeight\n    });\n\n    if (footerFn) {\n      var value = footerFn(item, i, items);\n\n      if (value != null) {\n        cells.push({\n          i: j++,\n          type: CELL_TYPE_FOOTER,\n          value: value,\n          index: i,\n          height: footerHeight ? footerHeight(value, i) : approxFooterHeight,\n          reads: footerHeight ? 0 : MIN_READS,\n          visible: !!footerHeight\n        });\n      }\n    }\n  }\n\n  return cells;\n};\n\nvar calcHeightIndex = function calcHeightIndex(buf, cells, index) {\n  var acum = buf[index];\n\n  for (var i = index; i < buf.length; i++) {\n    buf[i] = acum;\n    acum += cells[i].height;\n  }\n\n  return acum;\n};\n\nvar resizeBuffer = function resizeBuffer(buf, len) {\n  if (!buf) {\n    return new Uint32Array(len);\n  }\n\n  if (buf.length === len) {\n    return buf;\n  } else if (len > buf.length) {\n    var newBuf = new Uint32Array(len);\n    newBuf.set(buf);\n    return newBuf;\n  } else {\n    return buf.subarray(0, len);\n  }\n};\n\nvar positionForIndex = function positionForIndex(index, cells, heightIndex) {\n  var cell = cells.find(function (c) {\n    return c.type === CELL_TYPE_ITEM && c.index === index;\n  });\n\n  if (cell) {\n    return heightIndex[cell.i];\n  }\n\n  return -1;\n};\n\nvar virtualScrollCss = \"ion-virtual-scroll{display:block;position:relative;width:100%;contain:strict;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}ion-virtual-scroll>.virtual-loading{opacity:0}ion-virtual-scroll>.virtual-item{position:absolute !important;top:0 !important;right:0 !important;left:0 !important;-webkit-transition-duration:0ms;transition-duration:0ms;will-change:transform}\";\n\nvar VirtualScroll =\n/** @class */\nfunction () {\n  function class_1(hostRef) {\n    var _this = this;\n\n    registerInstance(this, hostRef);\n    this.range = {\n      offset: 0,\n      length: 0\n    };\n    this.viewportHeight = 0;\n    this.cells = [];\n    this.virtualDom = [];\n    this.isEnabled = false;\n    this.viewportOffset = 0;\n    this.currentScrollTop = 0;\n    this.indexDirty = 0;\n    this.lastItemLen = 0;\n    this.totalHeight = 0;\n    /**\n     * It is important to provide this\n     * if virtual item height will be significantly larger than the default\n     * The approximate height of each virtual item template's cell.\n     * This dimension is used to help determine how many cells should\n     * be created when initialized, and to help calculate the height of\n     * the scrollable area. This height value can only use `px` units.\n     * Note that the actual rendered size of each cell comes from the\n     * app's CSS, whereas this approximation is used to help calculate\n     * initial dimensions before the item has been rendered.\n     */\n\n    this.approxItemHeight = 45;\n    /**\n     * The approximate height of each header template's cell.\n     * This dimension is used to help determine how many cells should\n     * be created when initialized, and to help calculate the height of\n     * the scrollable area. This height value can only use `px` units.\n     * Note that the actual rendered size of each cell comes from the\n     * app's CSS, whereas this approximation is used to help calculate\n     * initial dimensions before the item has been rendered.\n     */\n\n    this.approxHeaderHeight = 30;\n    /**\n     * The approximate width of each footer template's cell.\n     * This dimension is used to help determine how many cells should\n     * be created when initialized, and to help calculate the height of\n     * the scrollable area. This height value can only use `px` units.\n     * Note that the actual rendered size of each cell comes from the\n     * app's CSS, whereas this approximation is used to help calculate\n     * initial dimensions before the item has been rendered.\n     */\n\n    this.approxFooterHeight = 30;\n\n    this.onScroll = function () {\n      _this.updateVirtualScroll();\n    };\n  }\n\n  class_1.prototype.itemsChanged = function () {\n    this.calcCells();\n    this.updateVirtualScroll();\n  };\n\n  class_1.prototype.connectedCallback = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var contentEl, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            contentEl = this.el.closest('ion-content');\n\n            if (!contentEl) {\n              console.error('<ion-virtual-scroll> must be used inside an <ion-content>');\n              return [2\n              /*return*/\n              ];\n            }\n\n            _a = this;\n            return [4\n            /*yield*/\n            , contentEl.getScrollElement()];\n\n          case 1:\n            _a.scrollEl = _b.sent();\n            this.contentEl = contentEl;\n            this.calcCells();\n            this.updateState();\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  class_1.prototype.componentDidUpdate = function () {\n    this.updateState();\n  };\n\n  class_1.prototype.disconnectedCallback = function () {\n    this.scrollEl = undefined;\n  };\n\n  class_1.prototype.onResize = function () {\n    this.calcCells();\n    this.updateVirtualScroll();\n  };\n  /**\n   * Returns the position of the virtual item at the given index.\n   */\n\n\n  class_1.prototype.positionForItem = function (index) {\n    return Promise.resolve(positionForIndex(index, this.cells, this.getHeightIndex()));\n  };\n  /**\n   * This method marks a subset of items as dirty, so they can be re-rendered. Items should be marked as\n   * dirty any time the content or their style changes.\n   *\n   * The subset of items to be updated can are specifing by an offset and a length.\n   */\n\n\n  class_1.prototype.checkRange = function (offset, len) {\n    if (len === void 0) {\n      len = -1;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var length, cellIndex, cells;\n      return __generator(this, function (_a) {\n        // TODO: kind of hacky how we do in-place updated of the cells\n        // array. this part needs a complete refactor\n        if (!this.items) {\n          return [2\n          /*return*/\n          ];\n        }\n\n        length = len === -1 ? this.items.length - offset : len;\n        cellIndex = findCellIndex(this.cells, offset);\n        cells = calcCells(this.items, this.itemHeight, this.headerHeight, this.footerHeight, this.headerFn, this.footerFn, this.approxHeaderHeight, this.approxFooterHeight, this.approxItemHeight, cellIndex, offset, length);\n        this.cells = inplaceUpdate(this.cells, cells, cellIndex);\n        this.lastItemLen = this.items.length;\n        this.indexDirty = Math.max(offset - 1, 0);\n        this.scheduleUpdate();\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\n   * This method marks the tail the items array as dirty, so they can be re-rendered.\n   *\n   * It's equivalent to calling:\n   *\n   * ```js\n   * virtualScroll.checkRange(lastItemLen);\n   * ```\n   */\n\n\n  class_1.prototype.checkEnd = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        if (this.items) {\n          this.checkRange(this.lastItemLen);\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n\n  class_1.prototype.updateVirtualScroll = function () {\n    // do nothing if virtual-scroll is disabled\n    if (!this.isEnabled || !this.scrollEl) {\n      return;\n    } // unschedule future updates\n\n\n    if (this.timerUpdate) {\n      clearTimeout(this.timerUpdate);\n      this.timerUpdate = undefined;\n    } // schedule DOM operations into the stencil queue\n\n\n    readTask(this.readVS.bind(this));\n    writeTask(this.writeVS.bind(this));\n  };\n\n  class_1.prototype.readVS = function () {\n    var _a = this,\n        contentEl = _a.contentEl,\n        scrollEl = _a.scrollEl,\n        el = _a.el;\n\n    var topOffset = 0;\n    var node = el;\n\n    while (node && node !== contentEl) {\n      topOffset += node.offsetTop;\n      node = node.offsetParent;\n    }\n\n    this.viewportOffset = topOffset;\n\n    if (scrollEl) {\n      this.viewportHeight = scrollEl.offsetHeight;\n      this.currentScrollTop = scrollEl.scrollTop;\n    }\n  };\n\n  class_1.prototype.writeVS = function () {\n    var dirtyIndex = this.indexDirty; // get visible viewport\n\n    var scrollTop = this.currentScrollTop - this.viewportOffset;\n    var viewport = getViewport(scrollTop, this.viewportHeight, 100); // compute lazily the height index\n\n    var heightIndex = this.getHeightIndex(); // get array bounds of visible cells base in the viewport\n\n    var range = getRange(heightIndex, viewport, 2); // fast path, do nothing\n\n    var shouldUpdate = getShouldUpdate(dirtyIndex, this.range, range);\n\n    if (!shouldUpdate) {\n      return;\n    }\n\n    this.range = range; // in place mutation of the virtual DOM\n\n    updateVDom(this.virtualDom, heightIndex, this.cells, range); // Write DOM\n    // Different code paths taken depending of the render API used\n\n    if (this.nodeRender) {\n      doRender(this.el, this.nodeRender, this.virtualDom, this.updateCellHeight.bind(this));\n    } else if (this.domRender) {\n      this.domRender(this.virtualDom);\n    } else if (this.renderItem) {\n      forceUpdate(this);\n    }\n  };\n\n  class_1.prototype.updateCellHeight = function (cell, node) {\n    var _this = this;\n\n    var update = function update() {\n      if (node['$ionCell'] === cell) {\n        var style = window.getComputedStyle(node);\n        var height = node.offsetHeight + parseFloat(style.getPropertyValue('margin-bottom'));\n\n        _this.setCellHeight(cell, height);\n      }\n    };\n\n    if (node && node.componentOnReady) {\n      node.componentOnReady().then(update);\n    } else {\n      update();\n    }\n  };\n\n  class_1.prototype.setCellHeight = function (cell, height) {\n    var index = cell.i; // the cell might changed since the height update was scheduled\n\n    if (cell !== this.cells[index]) {\n      return;\n    }\n\n    if (cell.height !== height || cell.visible !== true) {\n      cell.visible = true;\n      cell.height = height;\n      this.indexDirty = Math.min(this.indexDirty, index);\n      this.scheduleUpdate();\n    }\n  };\n\n  class_1.prototype.scheduleUpdate = function () {\n    var _this = this;\n\n    clearTimeout(this.timerUpdate);\n    this.timerUpdate = setTimeout(function () {\n      return _this.updateVirtualScroll();\n    }, 100);\n  };\n\n  class_1.prototype.updateState = function () {\n    var shouldEnable = !!(this.scrollEl && this.cells);\n\n    if (shouldEnable !== this.isEnabled) {\n      this.enableScrollEvents(shouldEnable);\n\n      if (shouldEnable) {\n        this.updateVirtualScroll();\n      }\n    }\n  };\n\n  class_1.prototype.calcCells = function () {\n    if (!this.items) {\n      return;\n    }\n\n    this.lastItemLen = this.items.length;\n    this.cells = calcCells(this.items, this.itemHeight, this.headerHeight, this.footerHeight, this.headerFn, this.footerFn, this.approxHeaderHeight, this.approxFooterHeight, this.approxItemHeight, 0, 0, this.lastItemLen);\n    this.indexDirty = 0;\n  };\n\n  class_1.prototype.getHeightIndex = function () {\n    if (this.indexDirty !== Infinity) {\n      this.calcHeightIndex(this.indexDirty);\n    }\n\n    return this.heightIndex;\n  };\n\n  class_1.prototype.calcHeightIndex = function (index) {\n    if (index === void 0) {\n      index = 0;\n    } // TODO: optimize, we don't need to calculate all the cells\n\n\n    this.heightIndex = resizeBuffer(this.heightIndex, this.cells.length);\n    this.totalHeight = calcHeightIndex(this.heightIndex, this.cells, index);\n    this.indexDirty = Infinity;\n  };\n\n  class_1.prototype.enableScrollEvents = function (shouldListen) {\n    var _this = this;\n\n    if (this.rmEvent) {\n      this.rmEvent();\n      this.rmEvent = undefined;\n    }\n\n    var scrollEl = this.scrollEl;\n\n    if (scrollEl) {\n      this.isEnabled = shouldListen;\n      scrollEl.addEventListener('scroll', this.onScroll);\n\n      this.rmEvent = function () {\n        scrollEl.removeEventListener('scroll', _this.onScroll);\n      };\n    }\n  };\n\n  class_1.prototype.renderVirtualNode = function (node) {\n    var _a = node.cell,\n        type = _a.type,\n        value = _a.value,\n        index = _a.index;\n\n    switch (type) {\n      case CELL_TYPE_ITEM:\n        return this.renderItem(value, index);\n\n      case CELL_TYPE_HEADER:\n        return this.renderHeader(value, index);\n\n      case CELL_TYPE_FOOTER:\n        return this.renderFooter(value, index);\n    }\n  };\n\n  class_1.prototype.render = function () {\n    var _this = this;\n\n    return h(Host, {\n      style: {\n        height: this.totalHeight + \"px\"\n      }\n    }, this.renderItem && h(VirtualProxy, {\n      dom: this.virtualDom\n    }, this.virtualDom.map(function (node) {\n      return _this.renderVirtualNode(node);\n    })));\n  };\n\n  Object.defineProperty(class_1.prototype, \"el\", {\n    get: function get() {\n      return getElement(this);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(class_1, \"watchers\", {\n    get: function get() {\n      return {\n        \"itemHeight\": [\"itemsChanged\"],\n        \"headerHeight\": [\"itemsChanged\"],\n        \"footerHeight\": [\"itemsChanged\"],\n        \"items\": [\"itemsChanged\"]\n      };\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return class_1;\n}();\n\nvar VirtualProxy = function VirtualProxy(_a, children, utils) {\n  var dom = _a.dom;\n  return utils.map(children, function (child, i) {\n    var node = dom[i];\n    var vattrs = child.vattrs || {};\n    var classes = vattrs.class || '';\n    classes += 'virtual-item ';\n\n    if (!node.visible) {\n      classes += 'virtual-loading';\n    }\n\n    return Object.assign(Object.assign({}, child), {\n      vattrs: Object.assign(Object.assign({}, vattrs), {\n        class: classes,\n        style: Object.assign(Object.assign({}, vattrs.style), {\n          transform: \"translate3d(0,\" + node.top + \"px,0)\"\n        })\n      })\n    });\n  });\n};\n\nVirtualScroll.style = virtualScrollCss;\nexport { VirtualScroll as ion_virtual_scroll };"],"sourceRoot":""}